---
title: "EDA Vera"
output: pdf_document
date: "2024-05-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
load("Irish.RData")
```


```{r}
library(dplyr)
```


```{r}
df <- as.data.frame(Irish[2])[,2:6]
```

```{r}
summary(df)
```

Null vals: 

```{r}
colSums(is.na(df))
```



```{r}
library(ggplot2)

# Histogram of survey.meanDem
ggplot(df, aes(x=survey.meanDem)) +
  geom_histogram(binwidth=0.1, fill="skyblue", color="black", alpha=0.7) +
  theme_minimal() +
  labs(title="Histogram of survey.meanDem", x="survey.meanDem", y="Frequency")
```

```{r}
# Bar plot for survey.SOCIALCLASS
ggplot(df, aes(x=survey.SOCIALCLASS)) +
  geom_bar(fill="skyblue", color="black") +
  theme_minimal() +
  labs(title="Bar Plot of Social Class", x="Social Class", y="Frequency")
```


```{r}
# Histogram of survey.BUILT.YEAR
ggplot(df, aes(x=survey.BUILT.YEAR)) +
  geom_histogram(binwidth=5, fill="skyblue", color="black", alpha=0.7) +
  theme_minimal() +
  labs(title="Histogram of Built Year", x="Year Built", y="Frequency")
```

```{r}
# Bar plot for survey.OWNERSHIP
ggplot(data=df, aes(x=survey.OWNERSHIP)) +
  geom_bar(fill="skyblue") +
  theme_minimal() +
  labs(title="Distribution of Ownership Status", x="Ownership Status", y="Frequency")

```

```{r}
# Bar plot for survey.HEAT.HOME
ggplot(data=df, aes(x=survey.HEAT.HOME)) +
  geom_bar(fill="skyblue") +
  theme_minimal() +
  labs(title="Distribution of Home Heating Systems", x="Heating System", y="Frequency")

```

```{r}
library(GGally)  # For pairwise plots
```

```{r}
# Subset the dataframe to include only numerical variables
numerical_df <- df[, c("survey.meanDem", "survey.BUILT.YEAR")]

# Pairwise plot for numerical variables
ggpairs(numerical_df, 
        title = "Pairwise Plot for Numerical Variables")

```

```{r}
# Box plot for survey.meanDem vs survey.SOCIALCLASS
ggplot(df, aes(x=survey.SOCIALCLASS, y=survey.meanDem)) +
  geom_boxplot(fill="skyblue", color="black") +
  theme_minimal() 
```
```{r}
# Box plot for survey.meanDem vs survey.OWNERSHIP
ggplot(df, aes(x=survey.OWNERSHIP, y=survey.meanDem)) +
  geom_boxplot(fill="skyblue", color="black") +
  theme_minimal()
```

```{r}
# Box plot for survey.meanDem vs survey.HEAT.HOME
ggplot(df, aes(x=survey.HEAT.HOME, y=survey.meanDem)) +
  geom_boxplot(fill="skyblue", color="black") +
  theme_minimal() 

```


```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)

# Load the data
load("Irish.RData")
df <- as.data.frame(Irish[2])[,2:6]

# Categorize survey.meanDem into 5 groups
df$meanDem_group <- cut(df$survey.meanDem, 
                        breaks=5, 
                        labels=c("Very Low", "Low", "Medium", "High", "Very High"))

# Check the distribution of the new groups
mean_dem_distribution <- table(df$meanDem_group)
print(mean_dem_distribution)

```


```{r}
# Create a contingency table
contingency_table <- table(df$meanDem_group, df$survey.SOCIALCLASS)
print(contingency_table)

```

```{r}
# Convert the contingency table to a data frame for plotting
contingency_df <- as.data.frame(contingency_table)
colnames(contingency_df) <- c("MeanDemGroup", "SocialClass", "Count")

# Stacked bar plot
ggplot(contingency_df, aes(x=MeanDemGroup, y=Count, fill=SocialClass)) +
  geom_bar(stat="identity", position="stack") +
  theme_minimal() +
  labs(title="Distribution of Social Classes in Mean Demographic Groups", 
       x="Mean Demographic Group", 
       y="Number of People") +
  scale_fill_brewer(palette="Set3", name="Social Class")

```

```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)

# Load the data
load("Irish.RData")
df <- as.data.frame(Irish[2])[,2:6]

# Categorize survey.meanDem into 5 groups
df$meanDem_group <- cut(df$survey.meanDem, 
                        breaks=5, 
                        labels=c("Very Low", "Low", "Medium", "High", "Very High"))

# Check the distribution of the new groups
mean_dem_distribution <- table(df$meanDem_group)
print(mean_dem_distribution)

# Categorize survey.BUILT.YEAR into 5 groups
df$builtYear_group <- cut(df$survey.BUILT.YEAR, 
                          breaks=5, 
                          labels=c("Very Old", "Old", "Moderate", "Recent", "New"))

# Check the distribution of the new groups
built_year_distribution <- table(df$builtYear_group)
print(built_year_distribution)

# Create a contingency table
contingency_table <- table(df$meanDem_group, df$builtYear_group)
print(contingency_table)

# Convert the contingency table to a data frame for plotting
contingency_df <- as.data.frame(contingency_table)
colnames(contingency_df) <- c("MeanDemGroup", "BuiltYearGroup", "Count")

# Stacked bar plot
ggplot(contingency_df, aes(x=MeanDemGroup, y=Count, fill=BuiltYearGroup)) +
  geom_bar(stat="identity", position="stack") +
  theme_minimal() +
  labs(title="Distribution of Built Year Groups in Mean Demographic Groups", 
       x="Mean Demographic Group", 
       y="Number of People") +
  scale_fill_brewer(palette="Set3", name="Built Year Group")

```


```{r}
df <- as.data.frame(Irish[1])
```



--------------------------------------------------------------------------------------------------------------------------------------

```{r}
aggregated_data <- read.csv("AggregatedData1.csv")
daily_data <- read.csv("Daily_AggregatedData1.csv")
```

```{r}
cluster1_day <- daily_data[, -c(3,4,5,6,7)]

y <- cluster1_day$Cluster.1 
x1 <- cluster1_day$toy        # time of year
x2 <- cluster1_day$weekend    # weekend
x3 <- cluster1_day$temp       # temperature
```

```{r}
library(rjags)
```


```{r}
model_string <- "model {
  # Priors for the coefficients
  beta0 ~ dnorm(0, 0.01)
  beta1 ~ dnorm(0, 0.01)
  beta2 ~ dnorm(0, 0.01)
  beta3 ~ dnorm(0, 0.01)
  beta4 ~ dnorm(0, 0.01)
  beta5 ~ dnorm(0, 0.01)

  # Prior for the precision (inverse of variance)
  tau ~ dgamma(0.01, 0.01)
  
  # Initial value for y[1]
  y[1] ~ dnorm(0, 0.01)
  
  # Likelihood
  for (t in 2:N) {
    y[t] ~ dnorm(mu[t], tau)
    mu[t] <- beta0 + beta1 * y[t-1] +                                                # intercept and y[t-1]
             beta2 * sin(x1[t]) + beta3 * cos(x1[t]) +                               # time of year x1
             beta4 * x2[t] +                                                         # weekend x2 
             beta5 * x3[t]                                                           # temperature x3 
             }
  
}

"
```



```{r}
datalist <- list(N = length(y), x1=x1, x2=x2, x3=x3)
```


```{r}
model <- jags.model(file = textConnection(model_string), 
                    data = datalist, n.chains = 3)
update(model, n.iter = 1000)

Nrep = 10000

posterior_sample <- coda.samples(model,
                       variable.names = c("tau", "beta0", "beta1", "beta2", "beta3", "beta4", "beta5"),
                       n.iter = Nrep)
```

```{r}
summary(posterior_sample)
```

```{r}
gelman.diag(posterior_sample)
```

```{r}
gelman.plot(posterior_sample)
```


--------------------------------------------------------------------------------------------------------------------------------------


```{r}
cluster1_data <- aggregated_data[, -c(2,3,4,5,6)]

num_rows <- nrow(cluster1_data)

# Take a random sample of 3000 rows from cluster1_data
set.seed(123)  # Setting seed for reproducibility
sample_indices <- sample(num_rows, 10000)
sampled_data <- cluster1_data[sample_indices, ]

y <- sampled_data$Cluster.1 
x1 <- sampled_data$toy        # time of year
x2 <- sampled_data$weekend    # weekend
x3 <- sampled_data$temp       # temperature
x4 <- sampled_data$tod        # time of day
```


```{r}
model_string2 <- "model {
  # Priors for the coefficients
  beta0 ~ dnorm(0, 0.01)
  beta1 ~ dnorm(0, 0.01)
  beta2 ~ dnorm(0, 0.01)
  beta3 ~ dnorm(0, 0.01)
  beta4 ~ dnorm(0, 0.01)
  beta5 ~ dnorm(0, 0.01)
  beta6 ~ dnorm(0, 0.01)
  beta7 ~ dnorm(0, 0.01)
  beta8 ~ dnorm(0, 0.01)
  beta9 ~ dnorm(0, 0.01)
  
  # Prior for the precision (inverse of variance)
  tau ~ dgamma(0.01, 0.01)
  sigma <- 1 / sqrt(tau)
  
  # Initial value for y[1]
  y[1] ~ dnorm(0, 0.01)
  
  # Likelihood
  for (t in 2:N) {
    y[t] ~ dnorm(mu[t], tau)
    mu[t] <- beta0 + beta1 * y[t-1] +                                                # intercept and y[t-1]
             beta2 * sin(x1[t]) + beta3 * cos(x1[t]) +                               # time of year x1
             beta4 * x2[t] +                                                         # weekend x2
             beta5 * x3[t] +                                                         # temperature x3 
             beta6 * x4[t] + beta7 * x4[t]^2 + beta8 * x4[t]^3 + beta9 * x4[t]^4     # time of day x4                                
             }
  
}

"
```

```{r}
datalist <- list(N = length(y), x1=x1, x2=x2, x3=x3, x4=x4)
```


```{r}
model <- jags.model(file = textConnection(model_string2), 
                    data = datalist, n.chains = 3)
update(model, n.iter = 1000)

Nrep = 10000

posterior_sample <- coda.samples(model,
                       variable.names = c("tau", "beta0", "beta1", "beta2", "beta3", "beta4", "beta5",
                                          "beta6", "beta7", "beta8", "beta9"),
                       n.iter = Nrep)
```

```{r}
summary(posterior_sample)
```

```{r}
gelman.diag(posterior_sample)
```


